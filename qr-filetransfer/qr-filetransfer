#!/usr/bin/env python3

import qrcode
import http.server
import html
import socketserver
import random
import os
import socket
import sys
import shutil
from shutil import make_archive, rmtree, copy2
import pathlib
import signal
import platform
import argparse
import urllib.request, urllib.parse, urllib.error
import re
from io import BytesIO


MacOS = "Darwin"
Linux = "Linux"
Windows = "Windows"
operating_system = platform.system()


def FileTransferServerHandlerClass(file_name):

    class FileTransferServerHandler(http.server.SimpleHTTPRequestHandler):
        _file_name = file_name

        def do_GET(self):
            # the self.path will start by '/', we truncate it.
            request_path = self.path[1:]
            if request_path != self._file_name:
                # access denied
                self.send_response(403)
                self.send_header("Content-type", "text/html")
                self.end_headers()
            else:
                super().do_GET()

    return FileTransferServerHandler

def FileUploadServerHandlerClass(output_dir):

    class FileUploadServerHandler(http.server.BaseHTTPRequestHandler):
        absolute_path = os.path.abspath(output_dir)
        # Making the path look nicer
        # /User/Jeff/Downloads --> ~/Downloads
        home = os.path.expanduser("~")
        path = absolute_path
        _output_dir = path.replace(home, "~")

        def do_GET(self):
            f = self.send_head()
            if f:
                self.copyfile(f, self.wfile)
                f.close()

        def do_HEAD(self):
            f = self.send_head()
            if f:
                f.close()

        def do_POST(self):
            """Serve a POST request."""
            r, info = self.deal_post_data()
            print((r, info, "by: ", self.client_address))
            f = BytesIO()
            f.write(b'<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">')
            f.write(b"<html>\n<title>Upload Result Page</title>\n")
            f.write(b"<body>\n<h2>Upload Result Page</h2>\n")
            f.write(b"<hr>\n")
            if r:
                f.write(b"<strong>Success:</strong>")
            else:
                f.write(b"<strong>Failed:</strong>")
            f.write(info.encode())
            f.write(("<br><a href=\"%s\">back</a>" % self.headers['referer']).encode())
            f.write(b"<hr><small>Powerd By: ")
            f.write(b"<a href=\"https://github.com/sdushantha/\">")
            f.write(b"sdushantha</a> and \n")
            f.write(b"<a href=\"https://github.com/npes87184/\">")
            f.write(b"npes87184</a>, check new version at \n")
            f.write(b"<a href=\"https://pypi.org/project/qr-filetransfer/\">")
            f.write(b"here</a>.</small></body>\n</html>\n")
            length = f.tell()
            f.seek(0)
            self.send_response(200)
            self.send_header("Content-type", "text/html")
            self.send_header("Content-Length", str(length))
            self.end_headers()
            if f:
                self.copyfile(f, self.wfile)
                f.close()

        def deal_post_data(self):
            uploaded_files = []
            content_type = self.headers['content-type']
            if not content_type:
                return (False, "Content-Type header doesn't contain boundary")
            boundary = content_type.split("=")[1].encode()
            remainbytes = int(self.headers['content-length'])
            line = self.rfile.readline()
            remainbytes -= len(line)
            if not boundary in line:
                return (False, "Content NOT begin with boundary")
            while remainbytes > 0:
                line = self.rfile.readline()
                remainbytes -= len(line)
                fn = re.findall(r'Content-Disposition.*name="file"; filename="(.*)"', line.decode("utf-8", "backslashreplace"))
                if not fn:
                    return (False, "Can't find out file name...")
                fn = os.path.join(self._output_dir, fn[0])
                line = self.rfile.readline()
                remainbytes -= len(line)
                line = self.rfile.readline()
                remainbytes -= len(line)
                try:
                    out = open(fn, 'wb')
                except IOError:
                    return (False, "Can't create file to write, do you have permission to write?")
                else:
                    with out:
                        preline = self.rfile.readline()
                        remainbytes -= len(preline)
                        while remainbytes > 0:
                            line = self.rfile.readline()
                            remainbytes -= len(line)
                            if boundary in line:
                                preline = preline[0:-1]
                                if preline.endswith(b'\r'):
                                    preline = preline[0:-1]
                                out.write(preline)
                                uploaded_files.append(fn)
                                break
                            else:
                                out.write(preline)
                                preline = line
            return (True, "File '%s' upload success!" % ",".join(uploaded_files))

        def send_head(self):
            f = BytesIO()
            displaypath = html.escape(urllib.parse.unquote(self.path))
            f.write(b'<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">')
            f.write(("<html>\n<title>Please choose file to upload to %s</title>\n" % self._output_dir).encode())
            f.write(("<body>\n<h2>Please choose file to upload to %s</h2>\n" % self._output_dir).encode())
            f.write(b"<hr>\n")
            f.write(b"<form ENCTYPE=\"multipart/form-data\" method=\"post\">")
            f.write(b"<input name=\"file\" type=\"file\" multiple/>")
            f.write(b"<input type=\"submit\" value=\"upload\"/></form>\n")
            f.write(b"</body>\n</html>\n")
            length = f.tell()
            f.seek(0)
            self.send_response(200)
            self.send_header("Content-type", "text/html")
            self.send_header("Content-Length", str(length))
            self.end_headers()
            return f

        def copyfile(self, source, outputfile):
            shutil.copyfileobj(source, outputfile)

    return FileUploadServerHandler

def get_ssid():

    if operating_system == MacOS:
        ssid = os.popen("/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I | awk '/ SSID/ {print substr($0, index($0, $2))}'").read().strip()
        return ssid

    elif operating_system == "Linux":
       ssid = os.popen("iwgetid -r").read().strip()
       return ssid

    else:
        # List interface information and extract the SSID from Profile
        # note that if WiFi is not connected, Profile line will not be found and nothing will be returned.
        interface_info = os.popen("netsh wlan show interfaces").read()
        for line in interface_info.splitlines():
            if line.strip().startswith("Profile"):
                ssid = line.split(':')[1].strip()
                return ssid


def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        return s.getsockname()[0]
    except OSError:
        print("Network is unreachable")
        sys.exit()


def random_port():
    return random.randint(1024, 65535)


def print_qr_code(address):
    qr = qrcode.QRCode(version=1,
                error_correction=qrcode.constants.ERROR_CORRECT_L,
                box_size=10,
                border=4,)
    qr.add_data(address)
    qr.make()

    if operating_system != Windows:
        # According to gomercin on GitHub, print_tty
        # prints out gibberish.
        # print_tty() shows a better looking QR code.
        # So thats why I am using print_tty() instead
        # of print_ascii() for all operating systems
        qr.print_tty()

    else:
        qr.print_ascii()


def start_download_server(file_path, debug):
    PORT = random_port()
    LOCAL_IP = get_local_ip()
    SSID = get_ssid()

    if not os.path.exists(file_path):
        print("No such file or directory")
        return

    # Variable to mark zip for deletion, if the user uses a folder as an argument
    delete_zip = 0
    abs_path = os.path.normpath(os.path.abspath(file_path))
    file_dir = os.path.dirname(abs_path)
    file_path = os.path.basename(abs_path)

    # change to directory which contains file
    os.chdir(file_dir)

    # Checking if given file name or path is a directory
    if os.path.isdir(file_path):
        zip_name = pathlib.PurePosixPath(file_path).name

        try:
            # Zips the directory
            path_to_zip = make_archive(zip_name, "zip", file_path)
            file_path = os.path.basename(path_to_zip)
            delete_zip = file_path
        except PermissionError:
            print("Permission denied")
            sys.exit()

    # Tweaking file_path to make a perfect url
    file_path = file_path.replace(" ", "%20")

    handler = FileTransferServerHandlerClass(file_path)
    httpd = socketserver.TCPServer(("", PORT), handler)

    # This is the url to be encoded into the QR code
    address = "http://" + str(LOCAL_IP) + ":" + str(PORT) + "/" + file_path

    print("Scan the following QR code to start downloading.\nMake sure that your smartphone is connected to \033[1;94m{}\033[0m".format(SSID))

    # There are many times where I just need to visit the url
    # and cant bother scaning the QR code everytime when debugging
    if debug:
    	print(address)

    print_qr_code(address)

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass

    # If the user sent a directory, a zip was created
    # this deletes the first created zip
    if delete_zip != 0:
        os.remove(delete_zip)
    # Just being nice and not messing up your bash prompt :)
    print()

    sys.exit()

def start_upload_server(file_path, debug):
    PORT = random_port()
    LOCAL_IP = get_local_ip()
    SSID = get_ssid()

    if not os.path.exists(file_path):
        print("No such file or directory")
        return

    if not os.path.isdir(file_path):
        print("%s is not a folder." % file_path)
        return

    handler = FileUploadServerHandlerClass(file_path)
    httpd = socketserver.TCPServer(("", PORT), handler)

    # This is the url to be encoded into the QR code
    address = "http://" + str(LOCAL_IP) + ":" + str(PORT) + "/"

    print("Scan the following QR code to start uploading.\nMake sure that your smartphone is connected to \033[1;94m{}\033[0m".format(SSID))

    # There are many times where I just need to visit the url
    # and cant bother scaning the QR code everytime when debugging
    if debug:
    	print(address)

    print_qr_code(address)

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass

    # Just being nice and not messing up your bash prompt :)
    print()

    sys.exit()


def main():
    if operating_system != Windows:
        # SIGSTP does not work in Windows
        # This disables CTRL+Z while the script is running
        signal.signal(signal.SIGTSTP, signal.SIG_IGN)

    parser = argparse.ArgumentParser(description = "Transfer files over WiFi between your computer and your smartphone from the terminal")

    parser.add_argument('file_path', action="store", help="path that you want to transfer or store the received file.")
    parser.add_argument('-debug', '--debug', action="store_true", help="ehow the encoded url.")
    parser.add_argument('-receive', '-r', action="store_true", help="enable upload mode, received file will be stored at given path.")

    args = parser.parse_args()

    if args.receive:
        start_upload_server(file_path=args.file_path, debug=args.debug)
    else:
        start_download_server(file_path=args.file_path, debug=args.debug)

if __name__=="__main__":
	main()
